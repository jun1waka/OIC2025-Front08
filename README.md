# OIC2025-Front08
# 第2弾 JavaScript応用力向上のための30本ノック

## 概要

このリポジトリは、JavaScriptの基本的な文法を習得した方を対象に、より実践的なプログラミングロジックと思考力を養うために用意された、新しい30個の課題集です。

文字列・配列・オブジェクトの応用的な操作、日付オブジェクト、非同期処理、正規表現、例外処理など、一歩進んだJavaScriptの機能を網羅的に学習できるように設計されています。

## ファイル構成

```
.
├── index.html         # メインページ
├── css/
│   └── style.css      # スタイルシート
└── js/
    └── app.js         # 30個の課題を実装したJavaScriptファイル
```

## 学習の進め方

1.  **`index.html`をブラウザで開く**:
    まずは完成形を確認し、どのような課題が出題されるのか全体像を把握します。

2.  **このドキュメントの「課題一覧」を見る**:
    課題の内容とヒントだけを見て、自力で解けるか挑戦してみましょう。

3.  **このドキュメントの「解答用ひな形」を使う**:
    `js/app.js`にひな形をコピー＆ペーストして、各課題の関数内にコードを記述していきます。

4.  **このドキュメントの「考え方・解法」を読む**:
    行き詰まったら、各課題の詳細な解説を読み、理解を深めます。

5.  **コードを改造・再実装する**:
    解答例を参考に、自分なりのコードを書いてみましょう。

---

## 課題一覧

まずはヒントを元に、自力で解けるかチャレンジしてみましょう。

31. **配列の重複を削除**: 配列から重複する値を取り除いた新しい配列を作成してください。
    * ヒント: `Set` オブジェクトとスプレッド構文 `...` を使うと簡潔に書けます。
32. **文字列内の文字数カウント**: 指定された文字列の中に、特定の文字が何個含まれているか数えてください。
    * ヒント: `split()` メソッドで文字を分割し、配列の長さを利用する方法があります。
33. **配列のシャッフル**: 配列の要素をランダムに並び替えてください。
    * ヒント: フィッシャー–イェーツのシャッフルアルゴリズムが有名です。配列の後ろから要素を一つずつ選び、前の要素と交換していきます。
34. **オブジェクトの配列をソート**: オブジェクトの配列を、特定のプロパティ（例: `age`）の値で昇順にソートしてください。
    * ヒント: `sort()` メソッドに比較関数を渡します。 `(a, b) => a.age - b.age` のように書きます。
35. **回文（パリンドローム）判定**: 与えられた文字列が回文（前から読んでも後ろから読んでも同じ）かどうかを判定してください。
    * ヒント: 文字列を逆順にして、元の文字列と比較します。
36. **フィボナッチ数列**: フィボナッチ数列のn番目の数値を求めてください。
    * ヒント: ループを使って、前の2つの項を足し合わせて次の項を計算していきます。
37. **JSONとオブジェクトの変換**: JavaScriptオブジェクトをJSON文字列に、またJSON文字列をオブジェクトに変換してください。
    * ヒント: `JSON.stringify()` と `JSON.parse()` を使います。
38. **`setTimeout`による遅延実行**: 3秒後にコンソールにメッセージを表示してください。
    * ヒント: `setTimeout(コールバック関数, 遅延時間ミリ秒)` を使います。この課題はブラウザのコンソールで結果を確認します。
39. **`setInterval`による繰り返し実行**: 2秒ごとに現在時刻をコンソールに表示し、10秒後に停止してください。
    * ヒント: `setInterval` でタイマーを開始し、`clearInterval` で停止します。
40. **例外処理 `try...catch`**: わざとエラーを発生させ、`try...catch`文でエラーを捕捉してメッセージを表示してください。
    * ヒント: `try` ブロックにエラーが起きうる処理を、`catch` ブロックにエラー発生時の処理を書きます。
41. **現在の日付を指定フォーマットで表示**: `Date` オブジェクトを使い、`YYYY-MM-DD` 形式の文字列を作成してください。
    * ヒント: `getFullYear()`, `getMonth()`, `getDate()` を使います。`getMonth()` は0から始まる点に注意。
42. **配列内の最大値・最小値**: `for` ループを使って、数値配列の中から最大値と最小値を見つけてください。
    * ヒント: 最初の値を暫定の最大値・最小値とし、ループで比較・更新していきます。
43. **2つの配列の共通要素**: 2つの配列に共通して含まれる要素だけの新しい配列を作成してください。
    * ヒント: 一方の配列をループさせ、もう一方の配列に `includes()` メソッドで要素が含まれているか確認します。
44. **キャメルケースとスネークケースの変換**: `hello-world` を `helloWorld` に変換してください。
    * ヒント: `split('-')` で分割し、2つ目以降の単語の先頭を大文字にして `join('')` します。
45. **素数判定**: 与えられた数値が素数かどうかを判定してください。
    * ヒント: 2からその数の平方根までで割り切れる数があるかどうかを調べます。
46. **`slice`と`splice`の違い**: `slice` と `splice` をそれぞれ使って配列を操作し、結果の違いを示してください。
    * ヒント: `slice` は非破壊的（元の配列を変更しない）、`splice` は破壊的（元の配列を変更する）です。
47. **`find`と`filter`の違い**: `find` と `filter` をそれぞれ使って配列を操作し、結果の違いを示してください。
    * ヒント: `find` は最初に見つかった**要素**を返し、`filter` は条件に合うすべての要素を**配列**で返します。
48. **`Object.entries`の利用**: オブジェクトを `[キー, 値]` のペアの配列に変換してください。
    * ヒント: `Object.entries()` メソッドを使います。
49. **クラスの追加・削除・切り替え**: ボタンクリックでHTML要素の特定のクラスを追加、削除、または切り替えてください。
    * ヒント: `element.classList` の `add()`, `remove()`, `toggle()` メソッドを使います。
50. **フォーム入力値の取得**: テキストボックスに入力された値を取得し、表示してください。
    * ヒント: `input` 要素の `value` プロパティで値を取得できます。
51. **正規表現によるメールアドレス検証**: 文字列が基本的なメールアドレスの形式に一致するかどうかを正規表現で判定してください。
    * ヒント: `/^.+@.+\..+$/` のような簡単な正規表現と `test()` メソッドを使います。
52. **階乗の計算**: 数値の階乗（例: 5! = 5*4*3*2*1）を計算してください。
    * ヒント: `for` ループを使って1からその数まで掛け合わせていきます。
53. **多次元配列の平坦化**: `[[1, 2], [3, 4], [5]]` のような配列を `[1, 2, 3, 4, 5]` に変換してください。
    * ヒント: 配列の `flat()` メソッドが便利です。
54. **URLクエリパラメータの解析**: `?id=123&name=test` のような文字列を `{ id: '123', name: 'test' }` のオブジェクトに変換してください。
    * ヒント: `URLSearchParams` オブジェクトを使うと簡単に扱えます。
55. **ディープコピー（簡易版）**: ネストしたオブジェクトを完全にコピー（ディープコピー）する簡単な関数を作成してください。
    * ヒント: `JSON.stringify()` で一度文字列にしてから `JSON.parse()` で戻す方法が簡単です。
56. **イベントデリゲーション**: 親要素にイベントリスナーを設定し、クリックされた子要素を特定してください。
    * ヒント: 親要素の `click` イベントで `event.target` を調べることで、どの子要素がクリックされたか判別できます。
57. **`localStorage`への保存と読み込み**: テキストを`localStorage`に保存し、ブラウザをリロードしてもそのテキストが読み込まれるようにしてください。
    * ヒント: `localStorage.setItem()` で保存し、`localStorage.getItem()` で読み込みます。
58. **`Promise`を使った非同期処理**: 成功か失敗かをランダムに返す`Promise`を作成し、その結果を処理してください。
    * ヒント: `new Promise(...)` の中で `resolve()` か `reject()` を呼び出し、`.then()` と `.catch()` で結果を受け取ります。
59. **`async/await`を使った非同期処理**: 課題58の`Promise`を、`async/await`構文を使って処理してください。
    * ヒント: `async` 関数の中で `try...catch` を使い、`await` で `Promise` の結果を待ちます。
60. **Web API (Fetch) の利用**: [JSONPlaceholder](https://jsonplaceholder.typicode.com/users/1) からユーザーデータを取得して表示してください。
    * ヒント: `fetch()` 関数を使ってAPIにリクエストを送り、返ってきたレスポンスを `.json()` で処理します。

---

## 解答用ひな形 (`js/app.js`)

```javascript
// 即時実行関数でグローバルスコープの汚染を防ぎます
(function() {
    'use strict';

    // 課題を格納する配列
    const challenges = [
        // ここに31番から60番までの課題オブジェクトを記述します。
        // 例:
        // 31. 配列の重複を削除
        { title: '31. 配列の重複を削除', func: () => { 
            /* ここにコードを書いてください */ 
            return ''; 
        }},
        // ... 以下、60番まで続く
    ];

    // --- ここから下は変更しないでください ---
    // 結果を表示するロジック
    const resultsContainer = document.getElementById('results-container');
    if (!resultsContainer) {
        console.error('結果を表示するためのコンテナが見つかりません。');
        return;
    }

    challenges.forEach(challenge => {
        const card = document.createElement('div');
        card.className = 'challenge-card';

        const title = document.createElement('h3');
        title.textContent = challenge.title;
        card.appendChild(title);

        const resultDiv = document.createElement('div');
        resultDiv.className = 'result';
        card.appendChild(resultDiv);

        resultsContainer.appendChild(card);
        
        try {
            const result = challenge.func(card);
            if (result !== null) {
                if (typeof result === 'object' && result !== null) {
                    resultDiv.textContent = JSON.stringify(result, null, 2);
                } else {
                    resultDiv.textContent = result;
                }
            }
        } catch (error) {
            console.error(`課題 "${challenge.title}" でエラーが発生しました:`, error);
            resultDiv.textContent = `エラーが発生しました: ${error.message}`;
            resultDiv.style.color = '#f87171';
        }
    });

})();
```
